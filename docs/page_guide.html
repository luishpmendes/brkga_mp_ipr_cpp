

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Guide / Tutorial &mdash; BRKGA-MP-IPR 1.1.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/add_target.js"></script>
        <script src="_static/target-highlight.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom_theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/doxyrest-sphinx_rtd_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="BRKGA-MP-IPR License" href="page_license.html" />
    <link rel="prev" title="BRKGA-MP-IPR Guide and Documentation - C++ Version" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> BRKGA-MP-IPR
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Guide / Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tl-dr">TL;DR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#first-things-first-the-decoder-function">First things first: the decoder function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-chromosome-or-vector-of-doubles">The chromosome or vector of doubles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#back-to-the-decoder">Back to the decoder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-brkga-mp-ipr-algorithm-object">Building BRKGA-MP-IPR algorithm object</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialization-and-warm-start-solutions">Initialization and Warm-start solutions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warm-start-solutions">Warm-start solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optimization-time-evolving-the-population">Optimization time: evolving the population</a></li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-solutions-chromosomes">Accessing solutions/chromosomes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-path-relink">Implicit Path Relink</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#important-notes-about-ipr">Important notes about IPR</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shaking-and-resetting">Shaking and Resetting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-population-and-migration">Multi-population and migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulating-the-standard-brkga">Simulating the standard BRKGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-and-writing-parameters">Reading and writing parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#probable-valuable-tips">(Probable Valuable) Tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-warmup">Algorithm warmup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-decoders-and-timing">Complex decoders and timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-threading">Multi-threading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#known-issues">Known issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="page_license.html">BRKGA-MP-IPR License</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_todo.html">Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_md_src_contributing.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="global.html">API documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BRKGA-MP-IPR</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Guide / Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/page_guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="guide-tutorial">
<span id="doxid-guide"></span><span id="index-0"></span><h1>Guide / Tutorial<a class="headerlink" href="#guide-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>BRKGA-MP-IPR is a header-only framework, which means that you only need to
download the header files and tell your compiler to include the path to where
the files were downloaded.</p>
<p>Quick example (unix): assume we are in an empty folder. So, we copy/clone
BRKGA-IPR-MP first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/ceandrade/brkga_mp_ipr_cpp
Cloning into &#39;brkga_mp_ipr&#39;...
remote: Enumerating objects: 118, done.
remote: Counting objects: 100% (118/118), done.
remote: Compressing objects: 100% (112/112), done.
remote: Total 118 (delta 24), reused 0 (delta 0)
Receiving objects: 100% (118/118), 3.50 MiB | 3.66 MiB/s, done.
Resolving deltas: 100% (24/24), done.
</pre></div>
</div>
<p>Let’s write a <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code> with the following code:</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Testing sense: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">Sense</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>Then, let’s compile and see it works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --version
g++ (MacPorts gcc8 8.2.0_3) 8.2.0

$ g++ -std=c++14 -Ibrkga_mp_ipr/brkga_mp_ipr test.cpp -o test

$ ./test
Testing sense: MINIMIZE
</pre></div>
</div>
<p>Note the Git clones the whole repository that contains the library code,
documents, and examples. All the examples were built using <a class="reference external" href="https://www.gnu.org/software/make/">GNU/Make</a> and <a class="reference external" href="https://gcc.gnu.org">GCC toolchain</a>. However, the code is standard C++, and we can
quickly adapt it to other toolchains such as <a class="reference external" href="https://clang.llvm.org">Clang</a>, <a class="reference external" href="https://visualstudio.microsoft.com">Microsoft</a>, or <a class="reference external" href="https://software.intel.com/en-us/c-compilers">Intel</a> toolchains. To build this
documentation, we also need <a class="reference external" href="http://www.doxygen.nl">Doxygen</a>.</p>
</div>
<div class="section" id="tl-dr">
<h2>TL;DR<a class="headerlink" href="#tl-dr" title="Permalink to this headline">¶</a></h2>
<p>The best way to keep it short is to look in the on examples on <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/master/examples">the git repo.</a>
Let’s take a look into
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/main_minimal.cpp">main_minimal.cpp</a>,
which solves the
<a class="reference external" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem (TSP)</a>.
This is a trimmed copy:</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&quot;tsp/tsp_instance.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;decoders/tsp_decoder.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &quot;</span><span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
             <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;seed&gt; &lt;config-file&gt; &lt;num-generations&gt;&quot;</span>
                <span class="s">&quot; &lt;tsp-instance-file&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">string</span> <span class="n">config_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_generations</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">string</span> <span class="n">instance_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">TSP_Instance</span><span class="p">(</span><span class="n">instance_file</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="n">config_file</span><span class="p">);</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">brkga_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>

    <span class="n">TSP_Decoder</span> <span class="n">decoder</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

    <span class="n">BRKGA</span><span class="o">::</span><span class="n">BRKGA_MP_IPR</span><span class="o">&lt;</span><span class="n">TSP_Decoder</span><span class="o">&gt;</span> <span class="n">algorithm</span><span class="p">(</span>
            <span class="n">decoder</span><span class="p">,</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">Sense</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
            <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">);</span>

    <span class="n">algorithm</span><span class="p">.</span><span class="n">initialize</span><span class="p">();</span>

    <span class="n">algorithm</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">num_generations</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">best_cost</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getBestFitness</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Best cost: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">best_cost</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>You can identify the following basic steps:</p>
<ol class="arabic simple">
<li><p>Create a data structure to hold your input data. This object should be
passed to the decoder object/functor (example
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/tsp/tsp_instance.hpp">tsp/tsp_instance.hpp</a>);</p></li>
<li><p>Implement a decoder object/functor. This function translates a chromosome
(array of numbers in the interval [0,1]) to a solution for your problem. The
decoder must return the solution value or cost to be used as fitness by
BRKGA (example <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/decoders/tsp_decoder.hpp">decoders/tsp_decoder.hpp</a>);</p></li>
<li><p>Load the instance and other relevant data;</p></li>
<li><p>Read the algorithm parameters using
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>;
or create a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object by hand;</p></li>
<li><p>Create an <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> algorithm object;</p></li>
<li><p>Call <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a7857351d4ce17199bd2fc157589a8592"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::initialize()</span></span></a></code> to init the BRKGA state;</p></li>
<li><p>Call <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::evolve()</span></span></a></code> to optimize;</p></li>
<li><p>Call <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1af0084ce8397e82db99391bf4dad85219"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::getBestFitness()</span></span></a></code> and/or <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa4b0396a4780fde3be8d284c535b600e"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::getBestChromosome()</span></span></a></code> to retrieve the best solution.</p></li>
</ol>
<p><a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/main_minimal.cpp">main_minimal.cpp</a>
provides a very minimal example to understand the necessary steps to use the
BRKGA-MP-IPR framework. However,
<cite>main_complete.cpp</cite> &lt;<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/main_complete.cpp">https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/main_complete.cpp</a>&gt;`_
provides a full-featured code, handy for scientific use, such as
experimentation and paper writing. This code allows fine-grained control of
the optimization, shows several features of BRKGA-MP-IPR such as the resets,
chromosome injection, and others. It also logs
all optimization steps, _creating outputs easy to be parsed._ <strong>You should use
this code for serious business and experimentation.</strong></p>
<p>These are the basic steps, but I do recommend the reading of this guide.</p>
</div>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>BRKGA-MP-IPR is pretty simple, and you must provide one required <em>decoder</em>
object to translate chromosomes to solutions. In general, such decoder uses
the problem information to map a vector of real numbers in the interval [0,1]
to a (valid) solution. In some cases, even though a valid solution cannot be
found, library users apply penalization factors and push the BRKGA to find
valid solutions.</p>
<p>Before you go further, please take a look at the <code class="docutils literal notranslate"><span class="pre">examples</span></code> folder in <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp">the
git repo</a>. There, you can find
two folders with codes to solve <a class="reference external" href="http://dx.doi.org/10.1162/EVCO_a_00138">combinatorial auction problems</a> and traveling salesman problems.
In this guide, we solve the classical <a class="reference external" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem</a>. Given aset of
cities and the distances between them (full weighted undirect graph), one
must find a minimum-cost tour among all cities, such that each city is
visited only once (i.e., find a Hamiltonian cycle of minimum cost). The
folder has the following structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code> subdir: contains all the code;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instances</span></code> subdir: folder containing some TSP instances for testing;</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">src</span></code> subdir contains all the code to solve TSP. This is its structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tsp</span></code> subdir: contains code to load and build data for TSP;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decoders</span></code> subdir: contains the TSP decoder;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">heuristics</span></code> subdir: contains a simple heuristic that computes a greedy
tour;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main_minimal.cpp</span></code> file: minimal code useful to understand and test the
framework. <strong>You should start here!</strong> Please take a look on this file before
continue this tutorial;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code> file: full-featured code, handy for scientific use,
such as experimentation and paper writing. This code allows fine-grained
control of the optimization, shows several features of BRKGA-MP-IPR such as
the path-relinking calls, resets, chromosome injection, and others. It also
logs all optimization steps, _creating outputs easy to be parsed._
<strong>You should use this code for serious business and experimentation;</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config.conf</span></code> file: example of parameter settings;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Makefile</span></code> file: the makefile used to build the executables;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">third_part</span></code> subdir: contains the <a class="reference external" href="https://github.com/docopt/docopt.cpp">docopt</a>
dependence for <code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code>. This is not strictly necessary for
BRKGA-MP-IPR, but it adds a nice command line interface. If you have problems
with that, we can change <code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code> using traditional argument
handling, or another library you prefer.</p></li>
</ul>
<p>The first step is to build the code. Here, we are using <a class="reference external" href="https://www.gnu.org/software/make">GNU/Make</a> and <a class="reference external" href="https://gcc.gnu.org">GCC toolchain</a>. You may change for the toolchain of your choice.
You may need to edit this file according to your compiler version and
settings. The first thing to note in the makefile is the parameter <code class="docutils literal notranslate"><span class="pre">OPT</span></code>
that, when set <code class="docutils literal notranslate"><span class="pre">OPT=opt</span></code>, it turns on aggressive optimization flags (for
G++). If the flag is not set, aggressive debug options are set. For serious
implementations, and debugging, we do recommend to use such setup. However,
if your compiler does not like such settings, please, go ahead and change
accordingly. By typing just <code class="docutils literal notranslate"><span class="pre">make</span></code>, you build both minimal and complete
versions. We also can just type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">main_minimal</span></code> or <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">main_complete</span></code> to build one or other version independently. Typing <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">clean</span></code> will clean up the compilation.</p>
<p>When you call the executables <code class="docutils literal notranslate"><span class="pre">main_minimal</span></code> or <code class="docutils literal notranslate"><span class="pre">main_complete</span></code> without
arguments, they show the usage. For example, assuming you are using a
terminal:</p>
<pre class="highlight literal-block"><span></span>$./main_minimal
Usage: ./main_minimal &lt;seed&gt; &lt;config-file&gt; &lt;num-generations&gt; &lt;tsp-instance-file&gt;

$ ./main_complete
Arguments did not match expected patterns
Usage:
  main_complete -c &lt;config_file&gt; -s &lt;seed&gt; -r &lt;stop_rule&gt; -a &lt;stop_arg&gt; -t &lt;max_time&gt; -i &lt;instance_file&gt; [-n &lt;num_threads&gt;] [--no_evolution]
  main_complete (-h | --help)
...</pre>
<p>So, this is a possible output whe calling <code class="docutils literal notranslate"><span class="pre">main_minimal</span></code> :</p>
<pre class="highlight literal-block"><span></span>$ ./main_minimal 27000001 config.conf 100 ../instances/brazil58.dat
Reading data...
Reading parameters...
Building BRKGA data and initializing...
Evolving 100 generations...
Best cost: 27709</pre>
<p>For <code class="docutils literal notranslate"><span class="pre">main_complete</span></code>, the output is more verbose, since we want to capture
as much information as possible to do some statistical analysis. The output
should be something close to this:</p>
<pre class="highlight literal-block"><span></span>$ ./main_complete -c config.conf -s 2700001 -r Generations -a 100 -t 60 -i ../instances/brazil58.dat
------------------------------------------------------
&gt; Experiment started at Tue Mar 12 10:03:31 2019
&gt; Instance: ../instances/brazil58.dat
&gt; Configuration: config.conf
&gt; Algorithm Parameters
&gt;   - population_size: 2000
&gt;   - elite_percentage: 0.3
&gt;   - mutants_percentage: 0
&gt;   - num_elite_parents: 2
&gt;   - total_parents: 3
&gt;   - bias_type: LOGINVERSE
&gt;   - num_independent_populations: 3
&gt;   - pr_number_pairs: 0
&gt;   - pr_minimum_distance: 0.15
&gt;   - pr_type: PERMUTATION
&gt;   - pr_selection: BESTSOLUTION
&gt;   - alpha_block_size: 1
&gt;   - pr_percentage: 1
&gt;   - exchange_interval: 200
&gt;   - num_exchange_individuals: 2
&gt;   - reset_interval: 600
&gt; Seed: 2700001
&gt; Stop rule: Generations
&gt; Stop argument: 100
&gt; Maximum time (s): 60
&gt; Number of parallel threads for decoding: 1
------------------------------------------------------

[Tue Mar 12 10:03:31 2019] Reading TSP data...
Number of nodes: 58

[Tue Mar 12 10:03:31 2019] Generating initial tour...
Initial cost: 30774

[Tue Mar 12 10:03:31 2019] Building BRKGA...
New population size: 580

[Tue Mar 12 10:03:31 2019] Injecting initial solution...

[Tue Mar 12 10:03:31 2019] Initializing BRKGA...

[Tue Mar 12 10:03:31 2019] Evolving...
* Iteration | Cost | CurrentTime
* 0 | 30774 | 0.02
* 24 | 30710 | 0.36
* 25 | 30536 | 0.37
* 26 | 30063 | 0.39
* 29 | 29956 | 0.43

[Tue Mar 12 10:03:32 2019] End of optimization

Total number of iterations: 101
Last update iteration: 29
Total optimization time: 1.35
Last update time: 0.43
Large number of iterations between improvements: 24
Total path relink time: 0.00
Total path relink calls: 0
Number of homogenities: 0
Improvements in the elite set: 0
Best individual improvements: 0

% Best tour cost: 29956
% Best tour: 0 29 12 39 24 8 31 19 52 49 3 17 43 23 57 4 26 42 11 56 22 53 54 1 40 34 9 51 50 46 48 2 47 38 28 35 16 25 5 18 27 13 36 14 33 45 55 44 32 20 10 15 21 7 37 41 30 6

Instance,Seed,NumNodes,TotalIterations,TotalTime,TotalPRTime,PRCalls,NumHomogenities,NumPRImprovElite,NumPrImprovBest,LargeOffset,LastUpdateIteration,LastUpdateTime,Cost
brazil58,2700001,58,101,1.35,0.00,0,0,0,0,24,29,0.43,29956</pre>
<p>I hope by now you got your system set up and running. Let’s see the essential
details on how to use the BRKGA-MP-IPR.</p>
</div>
<div class="section" id="first-things-first-the-decoder-function">
<h2>First things first: the decoder function<a class="headerlink" href="#first-things-first-the-decoder-function" title="Permalink to this headline">¶</a></h2>
<p>The core of the BRKGA algorithm is the definition of a decoder
function/object. The decoder maps the chromosomes (vectors of real numbers in
the interval [0, 1]) to solutions of the problem. In some sense, a decoder is
similar to a <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_method">kernel function from Support Vector Machines</a> : both functions are used to
project solutions/distances in different spaces.</p>
<p>Here, we have a small difference between the C++/Python and the Julia
implementations. In the Julia version, you must define a data container
inherit from <a class="reference external" href="https://ceandrade.github.io/brkga_mp_ipr_julia/guide/index.html#First-things-first:-basic-data-structures-and-decoder-function-1">AbstractInstance</a>,
and a decoder function. The reason you must do that is because structs in
Julia have no methods (but constructors), and the decoder function must take
both chromosome and input data in the call. In C++/Python, we can encapsulate the
input data into the decoder object, resulting in a much more clear API.</p>
<p>The basic form of a decoder should be:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="n">Decoder</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">decode</span><span class="p">(</span><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">BRKGA::Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span><span class="p">);</span>
<span class="p">};</span></pre>
<p>The decoder <strong>must</strong> contain a <strong>decode()</strong> method that receives a
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref"><span class="pre">BRKGA::Chromosome</span></span></a></code> reference
and an <code class="docutils literal notranslate"><span class="pre">boolean</span></code>, and returns a float point number. But before going
further, let’s talk about the chromosome.</p>
<div class="section" id="the-chromosome-or-vector-of-doubles">
<h3>The chromosome or vector of doubles<a class="headerlink" href="#the-chromosome-or-vector-of-doubles" title="Permalink to this headline">¶</a></h3>
<p>Note that all long the BRKGA discussion, the chromosome is represented as a
vector of real numbers in the interval [0,1]. Indeed, we could use
straightforward <code class="docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code>. However, sometimes is interesting to
keep more information inside the chromosome for further analysis, such as,
other solution metrics that not the main fitness value. For example, in a
scheduling problem, we may choose to keep both makespan and total completion
time metrics. Therefore, we chose to make the chromosome a “generic” data
structure in our design.</p>
<p>File <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/brkga_mp_ipr/chromosome.hpp">chomosome.hpp</a> shows the
basic represetation of a chromosome:</p>
<pre class="highlight literal-block"><span></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="p">;</span></pre>
<p>If this enough for you, you go already and use such a definition. However,
instead to redefine in your own code, <strong>we do recommend to import and use the
definition from</strong> <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/brkga_mp_ipr/chromosome.hpp">chomosome.hpp</a>,
since it is the same definition the main BRKGA-MP-IPR algorithm uses.</p>
<p>However, if you need more information to be tracked during the optimization,
you can redefine the chromosome. First, your definition must complain with
the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> interface. The easiest way to do that is to inherit
from the <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code>. For instance, assume we want to keep track of the
makespan and the total completion time for a scheduling problem. We can do
the following:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="p">()</span> <span class="o">:</span>
            std<span></span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">makespan</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">total_completion_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="p">{}</span>

        <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">_size</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
            std<span></span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_size</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
            <span class="n">makespan</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">total_completion_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="p">{}</span>

        <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chr</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="kt">double</span> <span class="n">makespan</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">total_completion_time</span><span class="p">;</span>
<span class="p">};</span></pre>
<p>In general, most people do not recommend to inherit publicly from
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> because it has no virtual destructor. However, we may do
that as long as:</p>
<ol class="loweralpha simple">
<li><p>We remember that every operation provided by <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> must be a
semantically valid operation on an object of the derived class;</p></li>
<li><p>We avoid creating derived class objects with dynamic storage duration;</p></li>
<li><p>We <strong>DO AVOID</strong> polymorphism:</p></li>
</ol>
<pre class="highlight literal-block"><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="p">();</span>     <span class="c1">// Bad idea.</span>
<span class="k">delete</span> <span class="n">pt</span><span class="p">;</span>      <span class="c1">// Delete does not call the Chromosome destructor.</span></pre>
</div>
<div class="section" id="back-to-the-decoder">
<h3>Back to the decoder<a class="headerlink" href="#back-to-the-decoder" title="Permalink to this headline">¶</a></h3>
<p>Again, the decoder is the heart of a BRKGA. An easy way to keep the API clean
is to define a decoder that has a reference for the input data. This is a TSP
decoder defined on file <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/decoders/tsp_decoder.hpp">decoders/tsp_decoder.hpp</a>:</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&quot;tsp/tsp_instance.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;chromosome.hpp&quot;</span><span class="cp"></span>
<span class="k">class</span> <span class="n">TSP_Decoder</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TSP_Decoder</span><span class="p">(</span><span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">decode</span><span class="p">(</span><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">BRKGA::Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">};</span></pre>
<p>Note that <code class="docutils literal notranslate"><span class="pre">TSP_Decoder</span></code> get a const reference to <code class="docutils literal notranslate"><span class="pre">TSP_Instance</span></code>, that holds
the input data. Therefore, <code class="docutils literal notranslate"><span class="pre">TSP_Decoder</span></code> has direct access to the data for
optimization. This approach also benefits cache efficiency, mainly when
multiple threads are used for decoding, i.e., several threads can use the same
read-only data already in the cache, which speeds up the optimization.</p>
<p>The decode method also has a <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> argument that indicates if the decoder
should rewrite the chromosome, in case of local search / local improvements be
performed during the decoder process. This flag is critical if you intend to
use the Implicit Path Relink (details on
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a95529466a3e942e4aafa26259aa83d0f"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::pathRelink()</span></span></a></code>).
Even though you do not rewrite the chromosome in your decoder, you must provide
such signature for API compatibility.</p>
<p>The decoder must return a <code class="docutils literal notranslate"><span class="pre">double</span></code> that is used as the <strong>fitness</strong> to rank
the chromosomes. In general, fitness is the cost/value of the solution, but you
may want to use it to penalize solutions that violate the problem constraints,
for example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using multiple threads, <strong>you must guarantee that the decoder is
thread-safe.</strong> You may want to create all read-write data structures on each
call or create a separate storage space for each thread. Section
<span class="xref std std-ref">Multi-threading</span> brings some
tips.</p>
</div>
<p>In our TSP example, we have a very simple decoder that generates a permutation
of nodes, and compute the cost of the cycle from that permutation
(note that we don’t use the flag <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> in this example):</p>
<pre class="highlight literal-block"><span></span><span class="kt">double</span> <span class="n">TSP_Decoder</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span>  <span class="kt">bool</span> <span class="cm">/* not-used */</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;</span> <span class="n">permutation</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">permutation</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="kt">double</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">,</span>
                                    <span class="n">permutation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">,</span>
                                  <span class="n">permutation</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>With the instance data and the decoder ready, we can build the BRKGA data
structures and perform the optimization.</p>
</div>
</div>
<div class="section" id="building-brkga-mp-ipr-algorithm-object">
<h2>Building BRKGA-MP-IPR algorithm object<a class="headerlink" href="#building-brkga-mp-ipr-algorithm-object" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> is the main object that
implements all BRKGA-MP-IPR algorithms such as evolution, path relink, and
other auxiliary procedures. Note that <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> is a template
parametrized by the decoder type. This strategy avoids runtime polymorphism,
drastically improving the performance of the code.</p>
<p>The first step is to call the algorithm constructor that has the following
signature:</p>
<pre class="highlight literal-block"><span></span><span class="n">BRKGA_MP_IPR</span><span class="p">(</span>
    <span class="n">Decoder</span><span class="o">&amp;</span> <span class="n">decoder_reference</span><span class="p">,</span>
    <span class="k">const</span> <a class="reference internal" href="enum_BRKGA_Sense.html#doxid-namespace-b-r-k-g-a-1af28538be111c8320b2fec44b77ec5e9b"><span class="std std-ref">Sense</span></a><span></span> <span class="n">sense</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">chromosome_size</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">BrkgaParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">evolutionary_mechanism_on</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span></pre>
<p>The first argument is the decoder object that must implement the <code class="docutils literal notranslate"><span class="pre">decode()</span></code>
method as discussed before. You also must indicate whether you are minimizing
or maximizing through parameter <code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_Sense.html#doxid-namespace-b-r-k-g-a-1af28538be111c8320b2fec44b77ec5e9b"><span class="std std-ref"><span class="pre">BRKGA::Sense</span></span></a></code>.</p>
<p>A good seed also must be provided for the (pseudo) random number generator
(according to <a class="reference external" href="http://doi.acm.org/10.1145/1276927.1276928">this paper</a>).
BRKGA-MP-IPR uses the Mersenne Twister engine
<a class="reference external" href="http://dx.doi.org/10.1145/272991.272995">[1]</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Mersenne_Twister">[2]</a>
from the standard C++ library
<a class="reference external" href="http://www.cplusplus.com/reference/random/mt19937">[3]</a>
<a class="reference external" href="https://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine">[4]</a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">chromosome_size</span></code> also must be given. It indicates the length of each
chromosome in the population. In general, this size depends on the instance and
how the decoder works. The constructor also takes a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object that holds several
parameters. We will take about that later.</p>
<p><code class="docutils literal notranslate"><span class="pre">max_threads</span></code> defines how many threads the algorithm should use for decoding
and some other operations. As said before, <strong>you must guarantee that the
decoder is thread-safe</strong> when using two or more threads. See
<span class="xref std std-ref">Multi-threading</span> for more
information.</p>
<p>Another common argument is <code class="docutils literal notranslate"><span class="pre">evolutionary_mechanism_on</span></code> which is enabled by
default. When disabled, no evolution is performed. The algorithm only decodes
the chromosomes and ranks them. On each generation, all population is replaced
excluding the best chromosome. This flag helps on implementations of simple
multi-start algorithms.</p>
<p>All BRKGA and Path Relink hyper-parameters
are stored in a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object. Such objects can be read
and write from plain text files or can be created by hand by the user. There is
also a companion <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ExternalControlParams.html#doxid-class-b-r-k-g-a-1-1-external-control-params"><span class="std std-ref"><span class="pre">BRKGA::ExternalControlParams</span></span></a></code> object that stores extra
control parameters that can be used outside the BRKGA-MP-IPR to control several
aspects of the optimization. For instance, interval to apply path relink, reset
the population, perform population migration, among others. This is how a
configuration file looks like (see <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/config.conf">config.conf</a>
for a commented version):</p>
<pre class="highlight literal-block"><span></span><span class="n">population_size</span> <span class="mi">2000</span>
<span class="n">elite_percentage</span> <span class="mf">0.30</span>
<span class="n">mutants_percentage</span> <span class="mf">0.15</span>
<span class="n">num_elite_parents</span> <span class="mi">2</span>
<span class="n">total_parents</span> <span class="mi">3</span>
<span class="n">bias_type</span> <a class="reference internal" href="enum_BRKGA_BiasFunctionType.html#doxid-namespace-b-r-k-g-a-1af0ede0f2a7123e654a4e3176b5539fb1adca762bd1443afdcf03af352da1c9184"><span class="std std-ref">LOGINVERSE</span></a><span></span>
<span class="n">num_independent_populations</span> <span class="mi">3</span>
<span class="n">pr_number_pairs</span> <span class="mi">0</span>
<span class="n">pr_minimum_distance</span> <span class="mf">0.15</span>
<span class="n">pr_type</span> <a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132a48deaef68056f516e0091a15c1db3daa"><span class="std std-ref">PERMUTATION</span></a><span></span>
<span class="n">pr_selection</span> <a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076faa6a169dcc4781fa0dc8c448d550be9d39"><span class="std std-ref">BESTSOLUTION</span></a><span></span>
<span class="n">alpha_block_size</span> <span class="mf">1.0</span>
<span class="n">pr_percentage</span> <span class="mf">1.0</span>
<span class="n">exchange_interval</span> <span class="mi">200</span>
<span class="n">num_exchange_individuals</span> <span class="mi">2</span>
<span class="n">reset_interval</span> <span class="mi">600</span></pre>
<p>To read this file, you can use the function <code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>, which
returns a <code class="docutils literal notranslate"><span class="pre">std::pair&lt;BrkgaParams,</span> <span class="pre">ExternalControlParams&gt;</span></code>. When reading such
file, the function ignores all blank lines, and lines starting with <code class="docutils literal notranslate"><span class="pre">#</span></code>. As
commented before, <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> contains all hyper-parameters
regarding <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a"><span class="std std-ref">BRKGA</span></a> and IPR methods and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ExternalControlParams.html#doxid-class-b-r-k-g-a-1-1-external-control-params"><span class="std std-ref"><span class="pre">BRKGA::ExternalControlParams</span></span></a></code> contains extra control
parameters, and although their presence is required on the config file, they
are not mandatory to the BRKGA-MP-IPR itself.</p>
<p>Let’s take a look in the example from <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/main_minimal.cpp">main_minimal.cpp</a>:</p>
<pre class="highlight literal-block"><span></span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">config_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_generations</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">instance_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

<span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">TSP_Instance</span><span class="p">(</span><span class="n">instance_file</span><span class="p">);</span>

<span class="c1">// C++14 syntax.</span>
<span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref">BRKGA::readConfiguration</span></a><span></span><span class="p">(</span><span class="n">config_file</span><span class="p">);</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">brkga_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>

<span class="c1">// C++17 syntax. Isn&#39;t cool?</span>
<span class="c1">// auto [brkga_params, control_params] =</span>
<span class="c1">//     BRKGA::readConfiguration(config_file);</span>

<span class="n">TSP_Decoder</span> <span class="nf">decoder</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>

<a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref">BRKGA::BRKGA_MP_IPR&lt;TSP_Decoder&gt;</span></a><span></span> <span class="n">algorithm</span><span class="p">(</span>
        <span class="n">decoder</span><span class="p">,</span> <a class="reference internal" href="enum_BRKGA_Sense.html#doxid-namespace-b-r-k-g-a-1af28538be111c8320b2fec44b77ec5e9ba704bfa6c1ed5e479c8cfb5bdfc8cccda"><span class="std std-ref">BRKGA::Sense::MINIMIZE</span></a><span></span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">);</span></pre>
<p>This code gets some arguments from the command line and loads a TSP instance.
After that, it reads the BRKGA parameters from the configuration file. Since in
this example, we only care about the BRKGA parameters, we ignore the control
parameters (tip: note how C++ 17 notation is much cleaner and more elegant than
the traditional version). We then build the decoder object, and the BRKGA
algorithm. Since we are looking for cycles of minimum cost, we ask for the
algorithm <code class="docutils literal notranslate"><span class="pre">MINIMIZE</span></code>. The starting seed is also given. Since <code class="docutils literal notranslate"><span class="pre">TSP_Decode</span></code>
considers each chromosome key as a node/city, the length of the chromosome must
be the number of nodes, i.e., <code class="docutils literal notranslate"><span class="pre">instance.num_nodes</span></code>. Finally, we also pass the
BRKGA parameters.</p>
<p>Now, we have a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> which will be used to
call all other functions during the optimization. Note that we can build
several <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> objects using different
parameters, decoders, or instance data. These structures can be evolved in
parallel and mixed-and-matched at your will. Each one holds a self-contained
BRKGA state including populations, fitness information, and a state of the
random number generator.</p>
</div>
<div class="section" id="initialization-and-warm-start-solutions">
<h2>Initialization and Warm-start solutions<a class="headerlink" href="#initialization-and-warm-start-solutions" title="Permalink to this headline">¶</a></h2>
<p>Before starting the optimization, we need to initialize the <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a"><span class="std std-ref">BRKGA</span></a> algorithm state using
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a7857351d4ce17199bd2fc157589a8592"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::initialize()</span></span></a></code>
method. This procedure initializes the populations and others data structures
of the BRKGA. If an initial population (warm
start) is supplied, the initialization method completes the remaining
individuals, if they do not exist. This method also performs the initial
decoding of the chromosomes. Therefore, depending on the decoder
implementation, this can take a while, and you may want to time such procedure.
Assuming that <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> is our <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code>
object, the syntax is pretty straightforward:</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">initialize</span><span class="p">();</span></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">initialize()</span></code> must be called before any optimization methods.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As it is in method <code class="docutils literal notranslate"><span class="pre">evolve()</span></code>, the decoding is done in parallel using
threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If
such property cannot be held, we suggest using a single thread for
optimization.</p>
</div>
<div class="section" id="warm-start-solutions">
<h3>Warm-start solutions<a class="headerlink" href="#warm-start-solutions" title="Permalink to this headline">¶</a></h3>
<p>One good strategy is to bootstrap the main optimization algorithm with good
solutions from fast heuristics
[<a class="reference external" href="http://dx.doi.org/10.1002/net.21685">1</a>,
<a class="reference external" href="http://dx.doi.org/10.1016/j.ejor.2017.10.045">2</a>,
<a class="reference external" href="http://dx.doi.org/10.1016/j.ejor.2017.10.045">3</a>]
or even from relaxations of integer linear programming models
<a class="reference external" href="http://dx.doi.org/10.1162/EVCO_a_00138">[4]</a>.</p>
<p>To do it, you must set these initial solutions before call <code class="docutils literal notranslate"><span class="pre">initialize()</span></code>.
Since BRKGA-MP-IPR does not know the problem structure, you must <em>encode</em> the
warm-start solution as chromosomes (vectors in the interval [0, 1]). In other
words, you must do the inverse process that your decoder does. For instance,
this is a piece of code from <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/main_complete.cpp">main_complete.cpp</a>
showing this process:</p>
<pre class="highlight literal-block"><span></span><span class="k">auto</span> <span class="n">initial_solution</span> <span class="o">=</span> <span class="n">greedy_tour</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="p">...</span>

<span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">key</span> <span class="p">:</span> <span class="n">keys</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">generate_canonical</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span>
                             <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">digits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>

<span class="n">sort</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">BRKGA::Chromosome</span></a><span></span> <span class="n">initial_chromosome</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">initial_tour</span> <span class="o">=</span> <span class="n">initial_solution</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">keys</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">initial_chromosome</span><span class="p">[</span><span class="n">initial_tour</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="n">algorithm</span><span class="p">.</span><span class="n">setInitialPopulation</span><span class="p">(</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_chromosome</span><span class="p">));</span></pre>
<p>Here, we create one incumbent solution using the greedy heuristic
<code class="docutils literal notranslate"><span class="pre">greedy_tour()</span></code> <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/v1.0/examples/tsp/src/heuristics">found here</a>.
It gives us
<code class="docutils literal notranslate"><span class="pre">initial_solution</span></code> which is a <code class="docutils literal notranslate"><span class="pre">std::pair&lt;double,</span> <span class="pre">std::vector&lt;unsigned&gt;&gt;</span></code>
containing the cost of the tour and the tour itself which is a sequence of
nodes to be visited. In the next lines, we encode <code class="docutils literal notranslate"><span class="pre">initial_solution</span></code>. First,
we create a vector of sorted random <code class="docutils literal notranslate"><span class="pre">keys</span></code>. For that, we create a new random
number generator <code class="docutils literal notranslate"><span class="pre">rng</span></code>, the vector <code class="docutils literal notranslate"><span class="pre">keys</span></code>, and fill up <code class="docutils literal notranslate"><span class="pre">keys</span></code> with random
numbers in the interval [0,1], using C++ standard library function
<code class="docutils literal notranslate"><span class="pre">generate_canonical&lt;&gt;()</span></code>. Once we have the keys, we sort them as
<code class="docutils literal notranslate"><span class="pre">TSP_Decoder::decode()</span></code> does. We then create the <code class="docutils literal notranslate"><span class="pre">initial_chromosome</span></code>, and
fill it up with <code class="docutils literal notranslate"><span class="pre">keys</span></code> according to the nodes’ order in <code class="docutils literal notranslate"><span class="pre">initial_solution</span></code>.
Finally, we use <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a59b05650ede92f5e0107ab606ff6e8b7"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::setInitialPopulation()</span></span></a></code>
to assign the incumbent to the initial population. Note that we enclose the
initial solution inside a vector of chromosomes, since
<code class="docutils literal notranslate"><span class="pre">setInitialPopulation()</span></code> may take more than one starting solution. See its
signature:</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span> <span class="nf">setInitialPopulation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Chromosome</span><span class="o">&gt;&amp;</span> <span class="n">chromosomes</span><span class="p">);</span></pre>
<p>Indeed, you can have as much warm-start solutions as you like, limited to the
size of the population. Just remember:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">setInitialPopulation()</span></code> must be called <strong>BEFORE</strong> <code class="docutils literal notranslate"><span class="pre">initialize()</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="optimization-time-evolving-the-population">
<h2>Optimization time: evolving the population<a class="headerlink" href="#optimization-time-evolving-the-population" title="Permalink to this headline">¶</a></h2>
<p>Once all data is set up, it is time to evolve the population and perform other
operations like path-relinking, shaking, migration, and others. The call is
pretty simple:</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">num_generations</span><span class="p">);</span></pre>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::evolve()</span></span></a></code>
evolves all populations for <code class="docutils literal notranslate"><span class="pre">num_generations</span></code>. If <code class="docutils literal notranslate"><span class="pre">num_genertions</span></code> is
omitted, <code class="docutils literal notranslate"><span class="pre">evolve()</span></code> evolves only one generation.</p>
<p>For example, in <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/main_minimal.cpp">main_minimal.cpp</a>, we just evolve the population for a given
number of generations directly and then extract the best solution cost.</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">num_generations</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">best_cost</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getBestFitness</span><span class="p">();</span></pre>
<p>On
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/main_complete.cpp">main_complete.cpp</a>
we have fine-grained control on the optimization.
There, we have a main loop that evolves the population one generation at a time
and performs several operations as to hold the best solution, to check whether
it is time for path relink, population reset, among others. The advantage of
that code is that we can track all optimization details, and I do recommend
similar style for experimentation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Again, the decoding of each chromosome is done in parallel if multi-thread is
enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If
such property cannot be held, we suggest using a single thread.</p>
</div>
</div>
<div class="section" id="accessing-solutions-chromosomes">
<h2>Accessing solutions/chromosomes<a class="headerlink" href="#accessing-solutions-chromosomes" title="Permalink to this headline">¶</a></h2>
<p>BRKGA-MP-IPR C++ offers several mechanisms to access a variaty of data during
the optimization. Most common, we want to access the best chromosome after some
iterations. You can use the companion functions:</p>
<pre class="highlight literal-block"><span></span><span class="kt">double</span> <span class="nf">getBestFitness</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">const</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">getBestChromosome</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></pre>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1af0084ce8397e82db99391bf4dad85219"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::getBestFitness()</span></span></a></code>
returns the value/fitness of the best chromosome across all populations.</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa4b0396a4780fde3be8d284c535b600e"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::getBestChromosome()</span></span></a></code>
returns a <em>reference</em> of the best chromosome across all populations. You may
want to extract an actual solution from such chromosome, i.e., to apply a
decoding function that returns the actual solution instead only its value.</p>
<p>You may also want to get a reference of specific chromosome and its fitness
for a given population using <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1abfe4eccfd47a8eb88fc920e640f8513f"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::getChromosome()</span></span></a></code>.</p>
<pre class="highlight literal-block"><span></span><span class="k">const</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">getChromosome</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>

<span class="k">const</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">getFitness</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span></pre>
<p>For example, you can get the 3rd best chromosome (and it fitness)
from the 2nd population using</p>
<pre class="highlight literal-block"><span></span><span class="n">third_best_chr</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getChromosome</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">third_best_fitness</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getFitness</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just remember that C++ is zero-indexed. So, the first population index is 0
(zero), the second population index is 1 (one), and so forth. The same happens
for the chromosomes.</p>
</div>
<p>Now, suppose you get such chromosome or chromosomes and apply a quick local
search procedure on them. It may be useful to reinsert such new solutions in
the BRKGA population for the next
evolutionary cycles. You can do that using
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a70bbe32b8bb3f662b629698319dc0261"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::injectChromosome()</span></span></a></code>.</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span> <span class="n">injectChromosome</span><span class="p">(</span><span class="k">const</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span>
                      <span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
                      <span class="kt">unsigned</span> <span class="n">position</span><span class="p">,</span>
                      <span class="kt">double</span> <span class="n">fitness</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">());</span></pre>
<p>Note that the chromosome is put in a specific position of a given population.
If you do not provide the fitness, <code class="docutils literal notranslate"><span class="pre">injectChromosome()</span></code> will decode the
injected chromosome. For example, assuming the <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> is your
BRKGA-MP-IPR object and <code class="docutils literal notranslate"><span class="pre">brkga_params</span></code> is your <code class="docutils literal notranslate"><span class="pre">BrkgaParams</span></code> object, the
following code injects the random chromosome <code class="docutils literal notranslate"><span class="pre">keys</span></code> into the population #1 in
the last position (<code class="docutils literal notranslate"><span class="pre">population_size</span></code>), i.e., it will replace the worst
solution by a random one:</p>
<pre class="highlight literal-block"><span></span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">key</span> <span class="p">:</span> <span class="n">keys</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">generate_canonical</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span>
                             <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">digits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>

<span class="n">algorithm</span><span class="p">.</span><span class="n">injectChromosome</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">.</span><span class="n">population_size</span><span class="p">);</span></pre>
</div>
<div class="section" id="implicit-path-relink">
<h2>Implicit Path Relink<a class="headerlink" href="#implicit-path-relink" title="Permalink to this headline">¶</a></h2>
<p>The Implicit Path Relinking (IPR) is a nice addition to the standard BRKGA
framework, and it provides an excellent way to create hybrid heuristics and
push the optimization further. The good thing about IPR is that you do not
need to worry about the path relink implementation, which can be long and
tedious if done by hand or customized per problem.</p>
<p>BRKGA-MP-IPR provides a friendly interface to use IPR directly from the BRKGA
population, and you only must provide a few functions and arguments to have a
Path Relink algorithm ready to go. This is the main signature of
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a95529466a3e942e4aafa26259aa83d0f"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::pathRelink()</span></span></a></code>
:</p>
<pre class="highlight literal-block"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253"><span class="std std-ref">PathRelinking::PathRelinkingResult</span></a><span></span> <span class="n">pathRelink</span><span class="p">(</span>
                <a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132"><span class="std std-ref">PathRelinking::Type</span></a><span></span> <span class="n">pr_type</span><span class="p">,</span>
                <a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076fa"><span class="std std-ref">PathRelinking::Selection</span></a><span></span> <span class="n">pr_selection</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DistanceFunctionBase</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="n">number_pairs</span><span class="p">,</span>
                <span class="kt">double</span> <span class="n">minimum_distance</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                <span class="kt">long</span> <span class="n">max_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                <span class="kt">double</span> <span class="n">percentage</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span></pre>
<p>The first argument defines the type of implicit path relink to be performed
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::Type</span></span></a></code>.
The <code class="docutils literal notranslate"><span class="pre">DIRECT</span></code> path relink exchanges the keys of two chromosomes directly, and
it is usually more suitable to or threshold representations, i.e., where the
key values are used to some kind of discretization, such as “if x &lt; 0.5, then
0, otherwise 1.” The <code class="docutils literal notranslate"><span class="pre">PERMUTATION</span></code> path relink switches the order of a key
according to its position in the other chromosome. Usually, this kind of path
relink is more suitable to permutation representations, where the chromosome
induces an order or permutation. For example, chromosome <code class="docutils literal notranslate"><span class="pre">[0.4,</span> <span class="pre">0.7,</span> <span class="pre">0.1]</span></code>
may induce the increasing order <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">1,</span> <span class="pre">2)</span></code>. More details about threshold and
permutation representations in <a class="reference external" href="https://doi.org/10.1016/j.ejor.2019.11.037">this paper</a>.</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076fa"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::Selection</span></span></a></code>
defines how the algorithm picks the chromosomes for relinking. <code class="docutils literal notranslate"><span class="pre">BESTSOLUTION</span></code>
selects, in the order, the best solution of each population. <code class="docutils literal notranslate"><span class="pre">RANDOMELITE</span></code>
chooses uniformly random solutions from the elite sets.</p>
<p>The next argument is a pointer to a functor object used to compute the distance
between two chromosomes, and determine if changes in a given (block) of alleles
change the solution. This object must inherit from
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_DistanceFunctionBase.html#doxid-class-b-r-k-g-a-1-1-distance-function-base"><span class="std std-ref"><span class="pre">BRKGA::DistanceFunctionBase</span></span></a></code>, which has the following
signature:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="n">DistanceFunctionBase</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DistanceFunctionBase</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">DistanceFunctionBase</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">distance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">v1</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">key2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v1_begin</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v2_begin</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></pre>
<p>Note that <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_DistanceFunctionBase.html#doxid-class-b-r-k-g-a-1-1-distance-function-base"><span class="std std-ref"><span class="pre">BRKGA::DistanceFunctionBase</span></span></a></code> is an abstract interface,
and children classes must implement all methods.</p>
<p>If the value returned by method <code class="docutils literal notranslate"><span class="pre">distance()</span></code> is greater than or equal to
<code class="docutils literal notranslate"><span class="pre">minimum_distance</span></code> (on <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> call), the algorithm will perform the
path relink between the two chromosomes. Otherwise, it will look for another
pair of chromosomes. The algorithm will try <code class="docutils literal notranslate"><span class="pre">number_pairs</span></code> chromosomes before
gives up. In the presence of multiple populations, the path relinking is
performed between elite chromosomes from different populations, in a circular
fashion. For example, suppose we have 3 populations. The framework performs 3
path relinkings: the first between individuals from populations 1 and 2, the
second between populations 2 and 3, and the third between populations 3 and 1.
In the case of just one population, both base and guiding individuals are
sampled from the elite set of that population.</p>
<p>Note that in traditional path relink algorithms, method <code class="docutils literal notranslate"><span class="pre">distance()</span></code> depends
on the problem structure. On IPR, you can use a generic distance function, or
provide one that incorporates more knowledge about the problem. BRKGA-MP-IPR
provides a class/functor to compute the (modified)
<a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a>
for threshold representations (<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_HammingDistance.html#doxid-class-b-r-k-g-a-1-1-hamming-distance"><span class="std std-ref"><span class="pre">BRKGA::HammingDistance</span></span></a></code>),
and a class/functor that computes the
<a class="reference external" href="https://en.wikipedia.org/wiki/Kendall_tau_distance">Kendall Tau distance</a>
distance for permutation representations (<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_KendallTauDistance.html#doxid-class-b-r-k-g-a-1-1-kendall-tau-distance"><span class="std std-ref"><span class="pre">BRKGA::KendallTauDistance</span></span></a></code>). Again, details about
threshold and permutation representations in <a class="reference external" href="https://doi.org/10.1016/j.ejor.2019.11.037">this paper</a>.</p>
<p>As a simple example, suppose you are using a threshold representation where
each chromosome key can represent one of 3 different values (a ternary
threshold representation). So, one possible way to compute the distance between
two chromosomes can be:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="nl">TernaryHammingDistance</span><span class="p">:</span> <span class="k">public</span> <span class="n">DistanceFunctionBase</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mf">0.33</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="mf">0.66</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">2.0</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">TernaryHammingDistance</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">TernaryHammingDistance</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">distance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">vector1</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">vector2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">vector1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="n">vector2</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">affectSolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">key2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="n">key2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">affectSolution</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v1_begin</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v2_begin</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">block_size</span><span class="p">;</span>
            <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">v1_begin</span><span class="p">,</span> <span class="o">++</span><span class="n">v2_begin</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">v1_begin</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">v2_begin</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre>
<p>To avoid changes that do not lead to new solutions, we must verify if such key
exchanges affect the solution. For that, the distance functor object must
implement the methods <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code>, which come with two signatures,
depicted in the previous example.</p>
<p>In the first version, <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> takes two keys and check whether the
exchange of <code class="docutils literal notranslate"><span class="pre">key1</span></code> by <code class="docutils literal notranslate"><span class="pre">key2</span></code> could change the solution. If so, the method
returns <code class="docutils literal notranslate"><span class="pre">true</span></code>. The second version takes two iterators for two chromosomes
and checks <code class="docutils literal notranslate"><span class="pre">block_size</span></code> keys from those iterators. The idea is, instead to
check only individual keys, we check an entire block of keys. This is very
usual for path relinks that exchange blocks of keys instead individual ones.
For instance, suppose that the alleles/keys are used as threshold such that
values &gt; 0.5 activate a feature. Suppose we have <code class="docutils literal notranslate"><span class="pre">chromosome1</span> <span class="pre">=</span> <span class="pre">[0.3,</span> <span class="pre">0.4,</span>
<span class="pre">0.1,</span> <span class="pre">0.8]</span></code> and <code class="docutils literal notranslate"><span class="pre">chromosome2</span> <span class="pre">=</span> <span class="pre">[0.6,</span> <span class="pre">0.1,</span> <span class="pre">0.2,</span> <span class="pre">0.9]</span></code>. If the key blocks start
on the first keys, and <code class="docutils literal notranslate"><span class="pre">block_size</span> <span class="pre">=</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> will return
<code class="docutils literal notranslate"><span class="pre">true</span></code> since the very first keys have different activation value. However, if
we start from the 3rd keys and exchange blocks of 2 keys (<code class="docutils literal notranslate"><span class="pre">[0.4,</span> <span class="pre">0.1]</span></code> by
<code class="docutils literal notranslate"><span class="pre">[0.1,</span> <span class="pre">0.2]</span></code>), nothing changes since both values have the same activation
level (&lt; 0.5). The blocks can hold only one key/allele, sequential key blocks,
or even the whole chromosome.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> is crucial to the IPR performance since this
function helps to avoid exploring regions already surveyed. Also, note that
<code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> can incorporate some problem knowledge.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation of permutation path relink does not make use of
<code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code>. However, <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code>) requires the function.
Therefore, we can implement simple constant methods:</p>
<pre class="highlight literal-block"><span></span><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">key2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v1_begin</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v2_begin</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></pre>
</div>
<p><code class="docutils literal notranslate"><span class="pre">block_size</span></code> defines the number of keys / size of the chromosome block to be
exchanged during the direct path relink. This parameter is also critical for
IPR performance since it avoids too many exchanges during the path building.
Usually, we can compute this number based on the size of the chromosome by some
factor (<code class="docutils literal notranslate"><span class="pre">alpha_block_size</span></code> in the configuration file), chosen by you. Again,
details <a class="reference external" href="https://doi.org/10.1016/j.ejor.2019.11.037">here</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Experiments have shown that a good choice is
<span class="math notranslate nohighlight">\(block\_size = alpha\_block\_size \times \sqrt{size~of~chromosome}\)</span></p>
</div>
<p>The last two parameters are stopping criteria. The algorithm stops either when
<code class="docutils literal notranslate"><span class="pre">max_time</span></code> seconds is reached or <code class="docutils literal notranslate"><span class="pre">percentage</span></code> % of the path is built.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>IPR is a very time-intensive process. You must set the stopping criteria
accordingly.</p>
</div>
<p>Let’s see the example on <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/main_complete.cpp">main_complete.cpp</a>.
Remember, since we are solving the TSP, we want to use the permutation-based
IPR, and the Kendall Tau distance functions.</p>
<pre class="highlight literal-block"><span></span><span class="k">if</span><span class="p">(</span><span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_type</span> <span class="o">==</span> <a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132a4c5d06b02c97731aaa976179c62dcf76"><span class="std std-ref">BRKGA::PathRelinking::Type::DIRECT</span></a><span></span><span class="p">)</span>
    <span class="n">dist_func</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <a class="reference internal" href="class_BRKGA_HammingDistance.html#doxid-class-b-r-k-g-a-1-1-hamming-distance"><span class="std std-ref">BRKGA::HammingDistance</span></a><span></span><span class="p">(</span><span class="mf">0.5</span><span class="p">));</span>
<span class="k">else</span>
    <span class="n">dist_func</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <a class="reference internal" href="class_BRKGA_KendallTauDistance.html#doxid-class-b-r-k-g-a-1-1-kendall-tau-distance"><span class="std std-ref">BRKGA::KendallTauDistance</span></a><span></span><span class="p">())</span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">pathRelink</span><span class="p">(</span>
    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_type</span><span class="p">,</span>
    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_selection</span><span class="p">,</span>
    <span class="n">dist_func</span><span class="p">,</span>
    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_number_pairs</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span> <span class="c1">// block_size doesn&#39;t not matter for permutation.</span>
    <span class="n">max_time</span> <span class="o">-</span> <span class="n">elapsedFrom</span><span class="p">(</span><span class="n">start_time</span><span class="p">),</span>
    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_percentage</span><span class="p">)</span></pre>
<p>Note that most parameters come from <code class="docutils literal notranslate"><span class="pre">brkga_params</span></code>. The maximum IPR time is
set to the remaining time for optimization (global <code class="docutils literal notranslate"><span class="pre">maximum_time</span></code> minus the
elapsed time). <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> returns a
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::PathRelinkingResult</span></span></a></code>
object which defines the status of the IPR optimization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TOO_HOMOGENEOUS</span></code> status is directly linked to the chosen distance
function and minimum distance. If the minimum distance is too large, IPR may
not be able to find a pair of chromosomes far enough for path relink.</p>
</div>
<p>If the found solution is the best solution found so far, IPR replaces the worst
solution by it. Otherwise, IPR computes the distance between the found solution
and all other solutions in the elite set, and replaces the worst solution by it
if and only if the found solution is, at least, <code class="docutils literal notranslate"><span class="pre">minimum_distance</span></code> from all
them.</p>
<div class="section" id="important-notes-about-ipr">
<h3>Important notes about IPR<a class="headerlink" href="#important-notes-about-ipr" title="Permalink to this headline">¶</a></h3>
<p>The API will call <code class="docutils literal notranslate"><span class="pre">decode()</span></code> function always with <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">false</span></code>. The
reason is that if the decoder rewrites the chromosome, the path between
solutions is lost and inadvertent results may come up. Note that at the end of
the path relinking, the method calls the decoder with <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">true</span></code> in
the best chromosome found to guarantee that this chromosome is re-written to
reflect the best solution found.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Make sure your decoder does not rewrite the chromosome when called with the
argument <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">false</span></code>.</p>
</div>
<p>BRKGA-MP-IPR <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> implementation is multi-threaded. Instead of to
build and decode each chromosome one at a time, the method builds a list of
candidates, altering the alleles/keys according to the guide solution, and then
decode all candidates in parallel. Note that
<span class="math notranslate nohighlight">\(O(chromosome\_size^2~/~block\_size)\)</span> additional memory is necessary to
build the candidates, which can be costly if the <code class="docutils literal notranslate"><span class="pre">chromosome_size</span></code> is very
large.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As it is in method <code class="docutils literal notranslate"><span class="pre">evolve()</span></code>, the decoding is done in parallel using
threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If
such property cannot be held, we suggest using a single thread for
optimization.</p>
</div>
</div>
</div>
<div class="section" id="shaking-and-resetting">
<h2>Shaking and Resetting<a class="headerlink" href="#shaking-and-resetting" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, BRKGA gets stuck, converging to local maxima/minima, for several
iterations. When such a situation happens, it is a good idea to perturb the
population, or even restart from a new one completely new. BRKGA-MP-IPR offers
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3721a91ed9d3fcbdc57fbcee2e20ac66"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::shake()</span></span></a></code>,
an improved variation of the original version proposed in <a class="reference external" href="http://dx.doi.org/10.1016/j.eswa.2019.03.007">this paper</a>.</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span> <span class="n">shake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">intensity</span><span class="p">,</span> <a class="reference internal" href="enum_BRKGA_ShakingType.html#doxid-namespace-b-r-k-g-a-1a616e3d7dedad5ff4e6a2961cda1ea494"><span class="std std-ref">ShakingType</span></a><span></span> <span class="n">shaking_type</span><span class="p">,</span>
           <span class="kt">unsigned</span> <span class="n">population_index</span> <span class="o">=</span>
               <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">());</span></pre>
<p><code class="docutils literal notranslate"><span class="pre">shake()</span></code> method gets an <code class="docutils literal notranslate"><span class="pre">intensity</span></code> parameter that measures how many times
the perturbation is applied on the elite set for a given <code class="docutils literal notranslate"><span class="pre">population_index</span></code>
(if not given, all populations are shaken). This method offers two
generic/implicit <code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_ShakingType.html#doxid-namespace-b-r-k-g-a-1a616e3d7dedad5ff4e6a2961cda1ea494"><span class="std std-ref"><span class="pre">BRKGA::ShakingType</span></span></a></code> s. With
<code class="docutils literal notranslate"><span class="pre">CHANGE</span></code>, direct modifications are done in the keys/alleles. This kind of
shaking is recommended when the chromosome uses direct or threshold
representations. <code class="docutils literal notranslate"><span class="pre">SWAP</span></code> exchanges keys/alleles inducing new permutations. For
representational definitions, please read <a class="reference external" href="https://doi.org/10.1016/j.ejor.2019.11.037">this paper</a>. For instance, the following
code shakes all populations using 10 swap moves:</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">shake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">SWAP</span><span class="p">);</span></pre>
<p>Sometimes, even shaking the populations does not help to escape from local
maxima/minima. So, we need a drastic measure, restarting from scratch the role
population. This can be easily accomplished with
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3bfe66221dd2f9c755a65ed7df14e350"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::reset()</span></span></a></code>.</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">reset()</span></code>, all warm-start solutions provided by
<code class="docutils literal notranslate"><span class="pre">setInitialPopulation()</span></code> are discarded. You may use <code class="docutils literal notranslate"><span class="pre">injectChromosome()</span></code>
to insert those solutions again.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Again, the decoding of each chromosome is done in parallel if multi-thread is
enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If
such property cannot be held, we suggest using a single thread..</p>
</div>
</div>
<div class="section" id="multi-population-and-migration">
<h2>Multi-population and migration<a class="headerlink" href="#multi-population-and-migration" title="Permalink to this headline">¶</a></h2>
<p>Multi-population or <em>island model</em> was introduced in genetic algorithms in
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.7225">this paper</a>. The idea
is to evolve parallel and independent populations and, once a while, exchange
individuals among these populations. In several scenarios, this approach is
very beneficial for optimization.</p>
<p>BRKGA-MP-IPR is implemented using such island idea from the core. If you read
the guide until here, you may notice that several methods take into account
multiple populations. To use multiple populations, you must set
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params-1a9a4a99536f6b755ceb07b54d784f8926"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams.num_independent_populations</span></span></a></code>
with 2 ou more populations, and build the BRKGA algorithm from such parameters.</p>
<p>The immigration process is implemented by</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span> <span class="nf">exchangeElite</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">num_immigrants</span><span class="p">);</span></pre>
<p><code class="docutils literal notranslate"><span class="pre">exchangeElite()</span></code> copies <code class="docutils literal notranslate"><span class="pre">num_immigrants</span></code> from one population to another,
replacing the worst <code class="docutils literal notranslate"><span class="pre">num_immigrants</span></code> individuals from the recipient
population. Note that the migration is done for all pairs of populations. For
instance, the following code exchanges 3 best individuals from each population:</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">exchangeElite</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span></pre>
</div>
<div class="section" id="simulating-the-standard-brkga">
<h2>Simulating the standard BRKGA<a class="headerlink" href="#simulating-the-standard-brkga" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, it is a good idea to test how the standard BRKGA algorithm performs
for a problem. You can use BRKGA-MP-IPR framework to quickly implement and test
a standard BRKGA.</p>
<p>First, you must guarantee that, during the crossover, the algorithm chooses
only one elite individual and only one non-elite individual. This is easily
accomplished setting <code class="docutils literal notranslate"><span class="pre">num_elite_parents</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">total_parents</span> <span class="pre">=</span> <span class="pre">2</span></code>. Then,
you must set up a bias function that ranks the elite and no-elite individual
according to the original BRKGA bias parameter <span class="math notranslate nohighlight">\(\rho\)</span> (rho).</p>
<p>You can use <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a8616c89626ca3c8e8d3b5adb1da24c92"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::setBiasCustomFunction()</span></span></a></code>
for that task. The given function receives the index of the chromosome and
returns a ranking for it. Such ranking is used in the roulette method to choose
the individual from which each allele comes to build the new chromosome. Since
we have one two individuals for crossover in the standard BRKGA, the bias
function must return the probability to one or other individual. In the
following code, we do that with a simple <code class="docutils literal notranslate"><span class="pre">if...else</span></code> lambda function.</p>
<pre class="highlight literal-block"><span></span><span class="c1">// Create brkga_params by hand or reading from a file,</span>
<span class="c1">// then set the following by hand.</span>
<span class="n">brkga_params</span><span class="p">.</span><span class="n">num_elite_parents</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">brkga_params</span><span class="p">.</span><span class="n">total_parents</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">double</span> <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">;</span>
<span class="n">algorithm</span><span class="p">.</span><span class="n">setBiasCustomFunction</span><span class="o">!</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="nl">rho</span> <span class="p">:</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">algorithm</span><span class="p">.</span><span class="n">initialize</span><span class="p">();</span></pre>
<p>Here, we first set the <code class="docutils literal notranslate"><span class="pre">num_elite_parents</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">total_parents</span> <span class="pre">=</span> <span class="pre">2</span></code> as
explained before. Following, we set a variable <code class="docutils literal notranslate"><span class="pre">rho</span> <span class="pre">=</span> <span class="pre">0.75</span></code>. This is the
<span class="math notranslate nohighlight">\(\rho\)</span> from standard BRKGA, and you may set it as you wish. Then, we set
the bias function as a very simple lambda function (note that we must use
<code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code> to capture <code class="docutils literal notranslate"><span class="pre">rho</span></code> in the outside context):</p>
<pre class="highlight literal-block"><span></span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="nl">rho</span> <span class="p">:</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>So, if the index of the chromosome is 1 (elite individual), it gets a 0.75
rank/probability. If the index is 2 (non-elite individual), the chromosome gets
0.25 rank/probability.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All these operations must be done before calling <code class="docutils literal notranslate"><span class="pre">initialize()</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that we consider the index 1 as the elite individual instead index
0, and index 2 to the non-elite individual opposed to index 1. The reason
for this is that, internally, BRKGA always pass <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> to the bias
function to avoid division-by-zero exceptions.</p>
</div>
</div>
<div class="section" id="reading-and-writing-parameters">
<h2>Reading and writing parameters<a class="headerlink" href="#reading-and-writing-parameters" title="Permalink to this headline">¶</a></h2>
<p>Although we can build the BRKGA algorithm data by set up a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object
manually, the easiest way to do so is to read such parameters from a
configuration file. For this, we can use <code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code> that reads a
simple plain text file and returns a tuple of <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ExternalControlParams.html#doxid-class-b-r-k-g-a-1-1-external-control-params"><span class="std std-ref"><span class="pre">BRKGA::ExternalControlParams</span></span></a></code> objects. For instance,</p>
<pre class="highlight literal-block"><span></span><span class="c1">// C++14 syntax.</span>
<span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref">BRKGA::readConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;tuned_conf.txt&quot;</span><span class="p">);</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">brkga_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">control_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

<span class="c1">// C++17 syntax. Isn&#39;t cool?</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">]</span> <span class="o">=</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref">BRKGA::readConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;tuned_conf.txt&quot;</span><span class="p">);</span></pre>
<p>The configuration file must be plain text such that contains pairs of
parameter name and value. This file must list all fields from
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ExternalControlParams.html#doxid-class-b-r-k-g-a-1-1-external-control-params"><span class="std std-ref"><span class="pre">BRKGA::ExternalControlParams</span></span></a></code>, even though you do
not use each one at this moment. In <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/v1.0/examples/tsp">examples folder</a>, we
have <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/config.conf">config.conf</a>
that looks like this:</p>
<pre class="highlight literal-block"><span></span><span class="n">population_size</span> <span class="mi">2000</span>
<span class="n">elite_percentage</span> <span class="mf">0.30</span>
<span class="n">mutants_percentage</span> <span class="mf">0.15</span>
<span class="n">num_elite_parents</span> <span class="mi">2</span>
<span class="n">total_parents</span> <span class="mi">3</span>
<span class="n">bias_type</span> <a class="reference internal" href="enum_BRKGA_BiasFunctionType.html#doxid-namespace-b-r-k-g-a-1af0ede0f2a7123e654a4e3176b5539fb1adca762bd1443afdcf03af352da1c9184"><span class="std std-ref">LOGINVERSE</span></a><span></span>
<span class="n">num_independent_populations</span> <span class="mi">3</span>
<span class="n">pr_number_pairs</span> <span class="mi">0</span>
<span class="n">pr_minimum_distance</span> <span class="mf">0.15</span>
<span class="n">pr_type</span> <a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132a48deaef68056f516e0091a15c1db3daa"><span class="std std-ref">PERMUTATION</span></a><span></span>
<span class="n">pr_selection</span> <a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076faa6a169dcc4781fa0dc8c448d550be9d39"><span class="std std-ref">BESTSOLUTION</span></a><span></span>
<span class="n">alpha_block_size</span> <span class="mf">1.0</span>
<span class="n">pr_percentage</span> <span class="mf">1.0</span>
<span class="n">exchange_interval</span> <span class="mi">200</span>
<span class="n">num_exchange_individuals</span> <span class="mi">2</span>
<span class="n">reset_interval</span> <span class="mi">600</span></pre>
<p>It does not matter whether we use lower or upper cases. Blank lines and lines
starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> are ignored. The order of the parameters should not
matter either. And, finally, this file should be readble for both C++, Julia,
and Python framework versions.</p>
<p>In some cases, you define some of the parameters at the running time, and you
may want to save them for debug or posterior use. To do so, you can use
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code>, call upon a
<code class="docutils literal notranslate"><span class="pre">BrkgaParams</span></code> object.</p>
<pre class="highlight literal-block"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref">writeConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;test.conf&quot;</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">);</span>
<span class="c1">//or</span>
<a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref">writeConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;test.conf&quot;</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">);</span></pre>
<p>If <code class="docutils literal notranslate"><span class="pre">control_params</span></code> is not given, default values are used in its place.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code>
rewrites the given file. So, watch out to not lose previous configurations.</p>
</div>
</div>
<div class="section" id="probable-valuable-tips">
<h2>(Probable Valuable) Tips<a class="headerlink" href="#probable-valuable-tips" title="Permalink to this headline">¶</a></h2>
<div class="section" id="algorithm-warmup">
<h3>Algorithm warmup<a class="headerlink" href="#algorithm-warmup" title="Permalink to this headline">¶</a></h3>
<p>While in Julia framework version is primordial to do a dry-run to precompile
all functions (and a good idea on Python version), in C++ and Python this
warmup is not necessary. However, few dry-runs can help the OS/processor with
cache locality and give some speedup..</p>
<p>Besides the dry-runs, I would recommend the pre-allocation of all
resource/memory that you need, if you know in advance how much will be
necessary. This pre-allocation speeds the decoding process dramatically.</p>
</div>
<div class="section" id="complex-decoders-and-timing">
<h3>Complex decoders and timing<a class="headerlink" href="#complex-decoders-and-timing" title="Permalink to this headline">¶</a></h3>
<p>Some problems require complex decoders while for others, the decoder contains
local search procedures, that can be time-consuming. In general, the decoding
is the most time-expensive component of a BRKGA algorithm, and it may skew some
stopping criteria based on running time. Therefore, if your decoder is
time-consuming, it is a good idea to implement a timer or chronometer kind of
thing inside the decoder.</p>
<p>Testing for stopping time uses several CPU cycles, and you need to be careful
when/where to test it, otherwise, you spend all the optimization time doing
system calls to the clock.</p>
<p>IMHO, the most effective way to do it is to test time at the very end of the
decoding. If the current time is larger than the maximum time allowed, simple
return <code class="docutils literal notranslate"><span class="pre">Inf</span></code> or <code class="docutils literal notranslate"><span class="pre">-Inf</span></code> according to your optimization direction. In this
way, we make the solution <strong>invalid</strong> since it violates the maximum time
allowed. The BRKGA framework takes care of the rest.</p>
</div>
<div class="section" id="multi-threading">
<h3>Multi-threading<a class="headerlink" href="#multi-threading" title="Permalink to this headline">¶</a></h3>
<p>Since <a class="reference external" href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore’s law</a> is not
holding its status anymore, we, simple mortals, must appeal to the wonders of
multi-threading. This paradigm can be tricky to code, and <a class="reference external" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a> plays against us. Several
genetic algorithms, and in particular, BRKGA, can use parallel solution
evaluation (or decoding), which makes the use of multi-threading relatively
straightforward. BRKGA-MP-IPR C++ framework is not different, and it uses
<a class="reference external" href="https://www.openmp.org">OpenMP</a> capabilities to do so.</p>
<p>First, as commented several times in this guide, <strong>the decoder must be
THREAD-SAFE.</strong> So, each thread must have its own read/write data structures and
may share other read-only data. The simplest way to do it is to create those
structures inside the decoder (like most people do). <strong>But be aware</strong>, this
strategy slows down the algorithm significantly depending on the size and
format of the structures, and <em>I do not recommend it</em>.</p>
<p>IMHO, the best way to do that is to preallocate the data structure per thread
and pass them to the decoder through the problem instance. Then, inside the
decoder, you can use <a class="reference external" href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5.0.pdf">omp_get_thread_num()</a>
and recover the memory you want to use.</p>
<p>Let’s see a simple example considering the TSP example. <code class="docutils literal notranslate"><span class="pre">TSP_Decode</span></code> uses a
single array to create the permutation of nodes. Let’s pre-allocate its memory
per thread. To keep things separeted and easy to understand, we created a new
class <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/v1.0/examples/tsp/src/decoders/tsp_decoder_pre_allocating.hpp">TSP_Decoder_pre_allocating</a>
so that we allocate, for each thread, a vector to hold the permutation during
the decoding:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="n">TSP_Decoder_pre_allocating</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TSP_Decoder_pre_allocating</span><span class="p">(</span><span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">,</span>
                               <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">decode</span><span class="p">(</span><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">BRKGA::Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;</span> <span class="n">Permutation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Permutation</span><span class="o">&gt;</span> <span class="n">permutation_per_thread</span><span class="p">;</span>
<span class="p">};</span></pre>
<p>Note that the constructor has one more argument indicating how many threads we
are using. We also define a type <code class="docutils literal notranslate"><span class="pre">Permutation</span></code> with is a simple vector of
key-node pairs. The important structure is <code class="docutils literal notranslate"><span class="pre">permuration_per_thread</span></code> which is
a simple vector of the size of the number of threads where we allocate the
permutation vectors for each thread.</p>
<p>Then, in the implementation, we allocate all memory in the constructor. In
<code class="docutils literal notranslate"><span class="pre">decode</span></code>, we use <a class="reference external" href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5.0.pdf">omp_get_thread_num()</a>
to identify which thread called the decoder, and retrieve the respective data
strucuture.</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="n">TSP_Decoder_pre_allocating</span><span class="o">::</span><span class="n">TSP_Decoder_pre_allocating</span><span class="p">(</span>
            <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">_instance</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span><span class="p">)</span><span class="o">:</span>
    <span class="n">instance</span><span class="p">(</span><span class="n">_instance</span><span class="p">),</span>
    <span class="c1">// Pre-allocate space for permutations for each thread.</span>
    <span class="n">permutation_per_thread</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">))</span>
<span class="p">{}</span>

<span class="kt">double</span> <span class="n">TSP_Decoder_pre_allocating</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ac1d4eb0799f47b27004f711bdffeb1c4"><span class="std std-ref">Chromosome</span></a><span></span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="cm">/* not-used */</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If you have OpenMP available, get the allocated memory per thread ID.</span>
    <span class="cp">#ifdef _OPENMP</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">permutation_per_thread</span><span class="p">[</span><span class="n">omp_get_thread_num</span><span class="p">()];</span>
    <span class="cp">#else</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">permutation_per_thread</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="cp">#endif</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">permutation</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="kt">double</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">,</span>
                                    <span class="n">permutation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">,</span>
                                  <span class="n">permutation</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">}</span></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pre-allocation and multi-threading only make sense for large data structures
and time-consuming decoders. Otherwise, the code spends too much time on
context switching and system calls.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Multi-threading consumes many resources of the machine and have diminishing
returns. I recommend using <strong>at most the number of physical cores</strong> (may -1)
to avoid racing and too much context switching. You must test which is the
best option for your case. In my experience, complex decoders benefit more
from multi-threading than simple and fast decoders.</p>
</div>
</div>
</div>
<div class="section" id="known-issues">
<h2>Known issues<a class="headerlink" href="#known-issues" title="Permalink to this headline">¶</a></h2>
<p>One of the interesting features implemented in this C++ BRKGA-MP-IPR framework
is the capability to easily load and write the algorithm configuration into
text files. To enable this feature, we borrow some nice code from Bradley Plohr
(<a class="reference external" href="https://codereview.stackexchange.com/questions/14309/conversion-between-enum-and-string-in-c-class-header">https://codereview.stackexchange.com/questions/14309/conversion-between-enum-and-string-in-c-class-header</a>),
which make easy to read and write enumerations from standard streams (cout and
cerr).</p>
<p>However, since BRKGA-MP-IPR is header-only, this feature can cause some
headaches during the linking, especially if you include the BRKGA-MP-IPR header
in different modules (translation units on C++ jargon) and compile them
separately (which normally we do). For example, suppose we have two pieces of
code, module_a.cpp and module_b.cpp, such that we include BRKGA in both (i.e.,
<code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;brkga_mp_ipr&gt;</span></code> in both files.</p>
<p>File module_a.cpp</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref">BRKGA::readConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;config.conf&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>File module_b.cpp</p>
<pre class="highlight literal-block"><span></span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref">BRKGA::readConfiguration</span></a><span></span><span class="p">(</span><span class="s">&quot;config.conf&quot;</span><span class="p">);</span>
<span class="p">}</span></pre>
<p>Let’s compile each one with GCC and link them:</p>
<pre class="highlight literal-block"><span></span>$ g++ -std=c++14 -I../brkga_mp_ipr -c module_a.cpp -o module_a.o

$ g++ -std=c++14 -I../brkga_mp_ipr -c module_b.cpp -o module_b.o

$ g++ module_a.o module_b.o -o test
duplicate symbol EnumIO&lt;BRKGA::PathRelinking::Selection&gt;::enum_names[abi:cxx11]()    in:
    module_a.o
    module_b.o
duplicate symbol EnumIO&lt;BRKGA::Sense&gt;::enum_names[abi:cxx11]()    in:
    module_a.o
    module_b.o
duplicate symbol EnumIO&lt;BRKGA::BiasFunctionType&gt;::enum_names[abi:cxx11]()     in:
    module_a.o
    module_b.o
duplicate symbol EnumIO&lt;BRKGA::PathRelinking::Type&gt;::enum_names[abi:cxx11]()    in:
    module_a.o
    module_b.o
duplicate symbol BRKGA::writeConfiguration(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, BRKGA::BrkgaParams const&amp;, BRKGA::ExternalControlParams const&amp;) in:
    module_a.o
    module_b.o
duplicate symbol BRKGA::readConfiguration(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) in:
    module_a.o
    module_b.o
ld: 6 duplicate symbols for architecture x86_64
collect2: error: ld returned 1 exit status</pre>
<p>Let’s try with Clang:</p>
<pre class="highlight literal-block"><span></span>$ clang++-mp-7.0 -std=c++14 -pthread -fopenmp -I../brkga_mp_ipr -c module_a.cpp -o module_a.o

$ clang++-mp-7.0 -std=c++14 -pthread -fopenmp -I../brkga_mp_ipr -c module_b.cpp -o module_b.o

$ clang++-mp-7.0 module_a.o module_b.o -o test
duplicate symbol __ZN6EnumIOIN5BRKGA13PathRelinking9SelectionEE10enum_namesEv in:
    module_a.o
    module_b.o
duplicate symbol __ZN6EnumIOIN5BRKGA5SenseEE10enum_namesEv in:
    module_a.o
    module_b.o
duplicate symbol __ZN6EnumIOIN5BRKGA16BiasFunctionTypeEE10enum_namesEv in:
    module_a.o
    module_b.o
duplicate symbol __ZN6EnumIOIN5BRKGA13PathRelinking4TypeEE10enum_namesEv in:
    module_a.o
    module_b.o
duplicate symbol __ZN5BRKGA18writeConfigurationERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS_11BrkgaParamsERKNS_21ExternalControlParamsE in:
    module_a.o
    module_b.o
duplicate symbol __ZN5BRKGA17readConfigurationERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE in:
    module_a.o
    module_b.o
ld: 6 duplicate symbols for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)</pre>
<p>So, note that we have several duplicated symbols, which are the <code class="docutils literal notranslate"><span class="pre">enum</span></code>
writer/readers, and the two stand-alone functions
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code> and
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>.</p>
<p>To avoid such a situation, we have to <code class="docutils literal notranslate"><span class="pre">inline</span></code> these functions and template
specializations. We can do that passing the compiler directive
<code class="docutils literal notranslate"><span class="pre">BRKGA_MULTIPLE_INCLUSIONS</span></code> which inlines the functions and template
specializations properly.</p>
<pre class="highlight literal-block"><span></span>$ g++ -std=c++14 -I../brkga_mp_ipr -DBRKGA_MULTIPLE_INCLUSIONS -c module_a.cpp -o module_a.o

$ g++ -std=c++14 -I../brkga_mp_ipr -DBRKGA_MULTIPLE_INCLUSIONS -c module_b.cpp -o module_b.o

$ g++ module_a.o module_b.o -o test</pre>
<p>However, we have two side-effects. First, such inlining can make the object
code grows large since we include several copies of the same functions (which
are I/O functions which already are large by their nature). Second, the
compiler may complain about too many inline functions, if you are already using
several inline functions.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Avoid including <code class="docutils literal notranslate"><span class="pre">brkga_mp_ip.hpp</span></code> in several files/translation units. If
unavoidable, use the compiler directive <code class="docutils literal notranslate"><span class="pre">BRKGA_MULTIPLE_INCLUSIONS</span></code>.</p>
</div>
<p>But now, suppose we must use multiple inclusions of BRKGA header, and our
compiler finds issues on inline such functions. The last resource is to move
functions <code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a01bade43afee725ca73c3f45a76012c4"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code> and
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ad212f0711891038e623f4d882509897e"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>, and all enum
template specializations (at the end of file <code class="docutils literal notranslate"><span class="pre">brkga_mp_ipr.hpp</span></code>), to a unique
translation unit. I recommend to it on your <code class="docutils literal notranslate"><span class="pre">main()</span></code> module, so that they are
compiled just once.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="page_license.html" class="btn btn-neutral float-right" title="BRKGA-MP-IPR License" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="BRKGA-MP-IPR Guide and Documentation - C++ Version" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Carlos E. Andrade

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
